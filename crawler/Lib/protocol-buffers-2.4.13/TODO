make changes to align with protocol-buffer 2.3.0 -- done

http://protobuf.googlecode.com/svn/trunk/CHANGES.txt

  General
  * Parsers for repeated numeric fields now always accept both packed and
    unpacked input.  The [packed=true] option only affects serializers.
    Therefore, it is possible to switch a field to packed format without
    breaking backwards-compatibility -- as long as all parties are using
    protobuf 2.3.0 or above, at least.

Should be possible to do this.
Reflection:
 add "FieldInfo.packedTag :: Maybe WireTag"
 need to make FieldInfo.wireTag always unpacked
 note that FieldInfo.wireTagLength is the same for both

Above may work except for loading previously unknown packed extensions 
Need to change Unknown.loadUnknown to tolerate the same field'Number with different wire types

MakeReflections:
 toFieldInfo'

Gen: allowed'wire'Tags gets both packed and unpacked codes for repeated
     update'Self must switch on wire'Tag not field'Number
                 and have both packed and unpacked cases for repeated

Gen: Clean up the generated wireGet code.

currently:
  wireGet ft'
   = case ft' of
       10 -> P'.getBareMessageWith check'allowed
       11 -> P'.getMessageWith check'allowed
       _ -> P'.wireGetErr ft'
    where
        update'Self wire'Tag old'Self
         = case wire'Tag of
             90 -> P'.wireGetKey UnittestProto.packed_int32_extension old'Self
             _ -> P'.unknownField old'Self (P'.fieldIdOf wire'Tag)

        check'allowed wire'Tag field'Number wire'Type old'Self
         = P'.catchError
            (if P'.member wire'Tag allowed'wire'Tags then update'Self wire'Tag old'Self else
              if P'.or [1 <= field'Number && field'Number <= 18999, 20000 <= field'Number] then
               P'.loadExtension (P'.fieldIdOf wire'Tag) wire'Type old'Self else
               P'.unknown (P'.fieldIdOf wire'Tag) wire'Type old'Self)
            (\ _ -> P'.loadUnknown (P'.fieldIdOf wire'Tag) wire'Type old'Self)

desired: 
        update'Self wire'Tag old'Self
         = case wire'Tag of
             90 -> P'.wireGetKey UnittestProto.packed_int32_extension old'Self
             _ -> let (field'Number,wire'Type) = splitWireTag wire'Tag
                  in if P'.or [1 <= field'Number && field'Number <= 18999, 20000 <= field'Number]
                       then P'.loadExtension field'Number wire'Type old'Self
                       else P'.unknown field'Number wire'Type old'Self
        check'allowed wire'Tag old'Self
         = P'.catchError (update'Self wire'Tag old'Self) (\ _ -> P'.loadUnknown wire'Tag old'Self)

without --unknown the code was

       check'allowed wire'Tag field'Number wire'Type old'Self
         = if P'.member wire'Tag allowed'wire'Tags then update'Self wire'Tag old'Self else
            if P'.or [1 <= field'Number && field'Number <= 18999, 20000 <= field'Number] then
             P'.loadExtension (P'.fieldIdOf wire'Tag) wire'Type old'Self else P'.unknown (P'.fieldIdOf wire'Tag) wire'Type old'Self
 
and should become 

             _ -> let (field'Number,wire'Type) = splitWireTag wire'Tag
                  in if P'.or [1 <= field'Number && field'Number <= 18999, 20000 <= field'Number]
                       then P'.loadExtension field'Number wire'Type old'Self
                       else P'.unknown field'Number wire'Type old'Self

   check'allowed = update'Self

Note that "unknownField", which was impossible, is no longer present.
check'allowed and update'Self and loadUnknown just takes the wire'Tag and old'Self,
while loadExtension and unknown are unchanged.
And allowed'wire'Tags can be dropped altogether.

The check'allowed is no longer needed when there is no catchError!
Thus rename to catch'Unknown ?  Still generate or put in library with INLINE ?
Put in library, now it will be

  wireGet ft'
   = case ft' of
       10 -> P'.getBareMessageWith (catch'Unknown update'Self)
       11 -> P'.getMessageWith (catch'Unknown update'Self)
       _ -> P'.wireGetErr ft'


  * The generic RPC service code generated by the C++, Java, and Python
    generators can be disabled via file options:
      option cc_generic_services = false;
      option java_generic_services = false;
      option py_generic_services = false;
    This allows plugins to generate alternative code, possibly specific to some
    particular RPC implementation.

Heh. It is always false for hprotoc

  protoc
  * Now supports a plugin system for code generators.  Plugins can generate
    code for new languages or inject additional code into the output of other
    code generators.  Plugins are just binaries which accept a protocol buffer
    on stdin and write a protocol buffer to stdout, so they may be written in
    any language.  See src/google/protobuf/compiler/plugin.proto.
    **WARNING**:  Plugins are experimental.  The interface may change in a
    future version.

Nope.

  * If the output location ends in .zip or .jar, protoc will write its output
    to a zip/jar archive instead of a directory.  For example:
      protoc --java_out=myproto_srcs.jar --python_out=myproto.zip myproto.proto
    Currently the archive contents are not compressed, though this could change
    in the future.

Nope.

  * inf, -inf, and nan can now be used as default values for float and double
    fields.

Should be possible to do this.
Done; required changes to the Lexer.x to recognize "-inf" as a discrete symbol.
NOT TESTED

----


Add even more of the documentation for the public API.
delete commented out code
add strictness annotations to internal data types.
benchmark
performance measure
